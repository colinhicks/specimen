<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <!-- <link rel="stylesheet" href="../../css/theme.css"> -->
    <!-- <link rel="stylesheet" href="../../css/github.css"> -->
    <link rel="stylesheet" href="styles-fragment.css" />
    <link rel="preload" as="font" href="https://www.confluent.io/fonts/MarkOT/MarkOT.woff2"/>
    <link rel="preload" as="font" href="https://www.confluent.io/fonts/MarkOT/MarkOT-Italic.woff2"/>
    <link rel="preload" as="font" href="https://www.confluent.io/fonts/MarkOT/MarkOT-Medium.woff2"/>
    <link rel="preload" as="font" href="https://www.confluent.io/fonts/MarkOT/MarkOT-MediumItalic.woff2"/>
    <link rel="preload" as="font" href="https://www.confluent.io/fonts/MarkOT/MarkOT-Bold.woff2"/>
    <link rel="preload" as="font" href="https://www.confluent.io/fonts/MarkOT/MarkOT-BoldItalic.woff2"/>
    <link rel="preload" as="font" href="https://www.confluent.io/fonts/MarkOT/MarkOT-NarrowLight.woff2"/>
    <link rel="preload" as="font" href="https://www.confluent.io/fonts/MarkOT/MarkOT-NarrowLightItalic.woff2"/>
    <link rel="stylesheet" href="https://www.confluent.io/fonts/fonts.css"/>
    <link href="https://cdn.confluent.io/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="https://www.confluent.io/css/main.css" rel="stylesheet"/>
    <link href="https://www.confluent.io/css/print.css" rel="stylesheet" media="print"/>

  </head>

  <body class="style-module--blogPost--1pOcN">
    <section class="style-module--sectionContent--3CzBg style-module--mainSection--3uX12" style="background:none;">
      <div class="style-module--contentContainer--NXLbe style-module--noBackground--2v_Ea">
        <div class="style-module--content--3iWje">
          <h1>How real-time stream processing works with ksqlDB, in 7 animations</h1>

          <p><a href="http://ksqldb.io/">ksqlDB</a>, the event streaming database, is becoming one of the most popular ways to work with Apache Kafka®. Every day, we answer many questions about the project, but here’s a question with an answer that we are always trying to improve: How does ksqlDB work?</p>
          
          <p>The mechanics behind stream processing can be challenging to grasp. The concepts are abstract, and many of them involve motion—two things that are hard for the mind’s eye to visualize. Let’s pop open the hood of ksqlDB to explore its essential concepts, how each works, and how it all relates to Kafka.</p>

          <p>If you like, you can follow along by executing the example code yourself. <a href="https://ksqldb.io/quickstart.html">ksqlDB's quickstart</a> makes it easy to get up and running.</p>

          <div>
            <h2>Declaring a stream</h2>
            <p>Stream processing is a programming paradigm for computing over events as they arrive. But where do those events come from? In Kafka, you store a collection of events in a <em>topic</em>. Each event can contain any raw bytes that you want. In ksqlDB, you store events in a <em>stream</em>. A stream is a topic with a strongly defined schema. You declare it like this:</p>

            <pre class="narrative-code">
              <code class="lang-sql">
CREATE STREAM readings (
    sensor VARCHAR KEY,
    location VARCHAR,
    reading INT
) WITH (
    kafka_topic = 'readings',
    partitions = 3,
    value_format = 'json'
);
              </code>
            </pre>

            <p>When you fire off this statement from ksqlDB’s client to its server, what actually happens? If the topic that backs this stream doesn’t exist, the server issues a call to the Kafka brokers to make a new topic with the specified number of partitions. The stream metadata, like the column layout, serialization scheme, and other information, is placed into ksqlDB’s command topic, which is its internal cluster communication channel. Each ksqlDB server materializes the command topic information to a local metadata store, giving it a global catalog of objects.</p>

            <p>A newly declared stream has no data in it:</p>
            <div class="specimen" id="stream">
            </div>
          </div>

          <div>
            <h2>Inserting rows</h2>
            <p>Empty collections aren’t terribly interesting. You need to write events to them to make something happen. In Kafka, you model an event as a <em>record</em> and put it into a topic. In ksqlDB, you model an event as a <em>row</em> and put it into a stream. A row is just a record with additional metadata. You <em>insert</em> rows like this:</p>

            <pre class="narrative-code"><code class="lang-sql">
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-1', 'wheel', 45);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-2', 'motor', 41);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-1', 'wheel', 42);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-3', 'muffler', 42);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-3', 'muffler', 40);

INSERT INTO readings (sensor, location, reading) VALUES ('sensor-4', 'motor', 43);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-6', 'muffler', 43);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-5', 'wheel', 41);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-5', 'wheel', 42);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-4', 'motor', 41);

INSERT INTO readings (sensor, location, reading) VALUES ('sensor-7', 'muffler', 43);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-8', 'wheel', 40);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-9', 'motor', 40);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-9', 'motor', 44);
INSERT INTO readings (sensor, location, reading) VALUES ('sensor-7', 'muffler', 41);
            </code></pre>

            <p>Each time you invoke an <code>INSERT</code> statement, a request with the payload is sent to a ksqlDB server. The server checks that the shape of the data is coherent with respect to the stream’s schema—malformed rows are rejected. If the row’s data types are sane, the server creates a record and automatically serializes its content using the format of choice as defined in the stream’s declaration. It uses the Kafka producer client to insert that record into the backing Kafka topic. All of the stream’s data is persisted on directly on the broker. None of it lives in ksqlDB’s servers.</p>

            <p>After the inserts complete, the stream now looks like what you see below. Hover over each row to see its contents—the data displayed describes the underlying Kafka record. Notice how the rows are ordered by offset from right to left. In the animations you'll see below, time is depicted as flowing rightward.</p>
            
            <div class="specimen" id="inserts">
            </div>

            <p>Why does some of the row data end up in the key of the record and some in the value? ksqlDB superimposes a flat column abstraction on top of Kafka’s key/value model. Here’s how it works in this case.</p>

            <p>In the declaration of the stream, <code>sensor</code> is qualified with the <code>KEY</code> keyword. That piece of syntax tells ksqlDB to look for the data for this column in the key portion of the record. The data for other columns is read from the record’s value. When ksqlDB produces the record to the underlying topic, its key content is hashed to select a partition for it to reside in. This causes all rows with the same key to be written to the same partition, which is a useful <a href="https://docs.confluent.io/current/kafka/introduction.html#topics-and-logs">ordering guarantee</a>.</p>
          </div>    

          <div>
            <h2>Transforming a stream</h2>
            <p>No one ever sends data to Kafka just to let it sit there. You always want to do something with it. And most often, the data isn’t yet in the exact form that you need in order to work with it. You need to change it in some way.</p>

            <p>The most elementary way you could do this is by writing a program that uses the Kafka producer and consumer clients. The program would read from the source topic whose data you want to change, apply a function to each record, and write the new record to the output topic. It would loop and run forever. This works, but it is rather low-level. You need to manage schemas, serializers, partitioning strategies, and other pieces of configuration.</p>

            <p>In ksqlDB, you issue a <em>persistent query</em> to <em>transform</em> one stream into another using its SQL programming model. You derive a new stream from an existing one by selecting and manipulating columns of interest:</p>

            <pre class="narrative-code"><code class="lang-sql">
-- process from the beginning of each stream
set 'auto.offset.reset' = 'earliest';
                
CREATE STREAM clean AS
    SELECT sensor,
           reading,
           UCASE(location) AS location
    FROM readings
    EMIT CHANGES;
            </code></pre>

            <p>Persistent queries are little stream processing programs that run indefinitely. In this case, it continually reads rows from <code>readings</code>, applies the transformation logic, and writes rows to <code>clean</code>. You are relieved of all data janitorial work: There are no schemas to manage, no serializers to configure, no partitioning strategies to choose. But what is actually happening when you launch this query?</p>

            <p>Each time you run a persistent query, ksqlDB’s server compiles the query’s textual representation to a physical execution plan as a Kafka Streams topology. The topology runs as a daemon, reacting to new topic records as soon as they become available. This means that all of the processing work happens on ksqlDB server; no processing work happens on the Kafka brokers. If you run ksqlDB as a cluster, the topology scales horizontally across the nodes by internally using Kafka Streams application IDs.</p>

            <p>When everything is connected together and the data is flowing, it looks like this. Take it in for a few moments—we’ll walk through it in detail below.</p>

            <div class="specimen" id="transformation">
            </div>

            <p>What is going on here? What do the moving arrows mean? Why are those numbers changing? And what is <code>pq1</code>?</p>

            <p>When a persistent query is created, it is assigned a generated name (in this case, we call it <code>pq1</code>). Rows are read from the stream partitions that the query selects from. As each row passes through the persistent query, the transformation logic is applied to create a new row, which is what the change of color signifies. Reading a record from Kafka does not delete it—you effectively receive a copy of it. That is why the leftmost rows remain in place, and clones of them appear to the right of each partition before they are sent to the persistent query box.</p>

            <p>Persistent queries completely manage their own processing progression, even in the presence of faults. ksqlDB durably maintains the highest offset of each input partition. The incrementing numbers underneath the query box describe those values at each point in time. Moreover, the arrows that move from right to left on the input streams show the corresponding offsets currently being processed, giving you a spatial sense of progress. (If you’re an experienced Kafka user, note that these aren’t the <em>committed</em> offsets.)</p>

            <p>Pause the animation and hover over the output rows. Notice how the column that the transformation targets has changed, while all the other columns remain intact. ksqlDB has taken care of all the bookkeeping for you.</p>

            <p>As you watch the data flowing through the topology, you might be wondering how ksqlDB chooses which input partition it will read from next. Is it random? Is it round robin? The answer to that question is the foundation of how ksqlDB deals with out-of-order data, and it’s something that we’ll describe in a future blog post all on its own. (Spoiler: <a href="https://www.confluent.io/resources/kafka-summit-2020/the-flux-capacitor-of-kafka-streams-and-ksqldb">It picks the smallest timestamp available</a>.)</p>
          </div>

          <div>
            <h2>Filtering rows out of a stream</h2>
            <p>Let’s look at another simple operation: filtering. Filters are used to discard rows that you do not need or want. Just like transforms, filters are specified using simple SQL syntax.</p>

            <pre class="narrative-code"><code class="lang-sql">
CREATE STREAM high_readings AS
    SELECT sensor, reading, location
    FROM clean
    WHERE reading > 41
    EMIT CHANGES;
            </code></pre>

            <p>When you write ksqlDB programs, you chain streams (and tables) together. You create a figurative pathway for your data to traverse, with each step in the way performing a step of processing. ksqlDB handles the mechanics of how your data is propagated through the chain.</p>

            <div class="specimen" id="filtering">
            </div>
          </div>

          <div>
            <h2>Combining many operations into one</h2>
            <p>A crucial rule of thumb in data processing is that you should get rid of data that you don’t need as early as possible. The longer you keep irrelevant data around, the higher the cost to repeatedly store, process, and transfer it. If you use the Kafka client to process data, it is up to you to manage where each processing step takes place.</p>

            <p>In ksqlDB, you can combine a wide range of operations into a single query. Its composable query syntax allows you to fuse discrete, yet logically conjoined operations into one.</p>

            <pre class="narrative-code"><code class="lang-sql">
CREATE STREAM high_pri AS
    SELECT sensor,
           reading,
           UCASE(location) AS location
    FROM readings
    WHERE reading > 41
    EMIT CHANGES;
            </code></pre>
            
            <p>This persistent query supplants the previous two that we wrote. It has the advantage of performing all of the computation in one physical place, discarding rows as early as possible.</p>

            <div class="specimen" id="compressed">
            </div>
          </div>

          <div>
            <h2>Rekeying a stream</h2>
            <p>No account of data processing is complete without a discussion of data locality. When you use a distributed system, data and computation are spread over a cluster of machines, each performing a small task that adds up to a larger operation. But even though your entire data corpus is available, you often want to perform processing over some smaller slice of it. Imagine that you’re building an analytics service. You might want to see what percentage of your users who live in Philadelphia are registered to vote. To do that, you need to gather only the records of users who live in the City of Brotherly Love. But where do you gather them when the data resides in different devices?</p>

            <p>In Kafka, partitioning controls data locality. Each partition lives in its entirety on a broker. That is why the choice of how you key your records is such a crucial one. If you use the Kafka clients to process your data, you need to be careful that you’ve set this up right. But in ksqlDB, this is just another SQL clause.</p>

            <pre class="narrative-code"><code class="lang-sql">
CREATE STREAM by_location AS
    SELECT *
    FROM high_pri
    PARTITION BY location
    EMIT CHANGES;
            </code></pre>

            <p>When you execute this statement, ksqlDB creates a new persistent query. It continually reads from <code>high_pri</code>, applies any additional logic (none in this case, as it simply selects everything), and writes a new record to <code>by_location</code> with a new key. The value of each key is the content of <code>location</code>. This has the effect of co-locating all rows with the same <code>location</code> in the same partition. This co-location property is essential for stateful operations like streaming join and incremental aggregations.</p>

            <div class="specimen" id="rekeying">
            </div>

            <p>Observe how all blocks of the same color end up on the same partition.</p>
          </div>

          <div>
            <h2>Processing with multiple consumers</h2>
            <p>One of the most important properties that Kafka offers is the ability for multiple consumers to read from the same topic in a conflict-free manner. Your program can read a series of records and do whatever it likes with them, and so can mine. We don’t need to agree about how to access the data before, during, or after.</p>

            <p>ksqlDB inherits this property. Every persistent query is transparently assigned a group ID, which means that multiple persistent queries can read from the same stream. They are guaranteed to receive the same rows in the same order for each partition. But this also means that when you add nodes to your cluster and scale an individual persistent query across them, they will collectively load balance the incoming data across them. The work will be shared, and no rows will be dropped or duplicated.</p>

            <p>Below is what it would look like if we added another persistent query (<code>pq3</code>, query omitted for brevity), which reads from the stream <code>high_pri</code>, shared by <code>pq2</code>. The persistent queries do not consume rows in lockstep. If <code>pq3</code> consumes messages more slowly than <code>pq2</code>, it doesn’t inhibit <code>pq2</code> in any way.</p>

            <div class="specimen" id="multi-consumer">
            </div>
          </div>

          <div>
            <h2>Learning more</h2>
            <p>We’ve only scratched the surface of how ksqlDB works, but we’ve seen that its key constructs are concise, composable, and elegant. They offer a higher-productivity interface for working with Kafka without diluting its core concepts.</p>

            <p>In future posts, we’ll dive into how tables, joins, scaling, fault tolerance, and time work. Each is a fascinating world in its own right. Until then, there’s no substitute for <a href="https://ksqldb.io/quickstart.html">trying ksqlDB yourself</a>.</p>
          </div>
        </div>
    </section>

    <script src="./bundle.js"></script>    
  </body>
</html>
